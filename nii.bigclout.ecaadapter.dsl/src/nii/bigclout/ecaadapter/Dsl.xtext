grammar nii.bigclout.ecaadapter.Dsl with org.eclipse.xtext.common.Terminals

generate dsl "http://www.bigclout.nii/ecaadapter/Dsl"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

RunTimeModel:
	{RunTimeModel}	
	envData += EnvironmentMetaData*
	appData += AppMetaData*  
	//servicesData += ServiceMetaData*  
	"ConceptToCodeMappings" 
	LBRACE
	mappingPairs += MappingPair*	
	RBRACE
;
	
AppMetaData:
	"AppMeta" appID=ID 
	LBRACE
	specifications += AppSpecification*
	RBRACE
;

/**
 * Currently AppSpecification only accommodates on-if-do, it does not take care of "else if...do...else...do..."
 */
AppSpecification:
	specID=ID 
	'on' trigger += OrElement*
	'if' condition += OrElement*
	'do' action += Action ("and" action+=Action)*
;

EnvironmentMetaData:
	{EnvironmentMetaData}
	"EnvironmentMetaData"
	LBRACE
	resources+=Resource*
	RBRACE
;

Resource:
	"name" name=ID
	"code" code=EXTENDED_STRING
	"possibleStates" states+=State*
;

State:
	ID | INT
;

Action:
	resource=[Resource] ":=" state=State	
;
/**
MappingPair:
	"(" concept = UnaryElement //UnaryElement???or just EXTENDED_STRING???? the design, e.g. Window, or Open
	"," code = EXTENDED_STRING  //the implementation, e.g. sensor1.service2; or [localGateway/window1/switch/state].get()==true
	")"
;
 */

MappingPair:
	"(" resource = [Resource] //UnaryElement???or just EXTENDED_STRING???? the design, e.g. Window, or Open
	"," state = UnaryElement
	"," actionCode = EXTENDED_STRING  //the implementation, e.g. sensor1.service2; or [localGateway/window1/switch/state].get()==true
	")"
;



OrElement returns Element:
	AndElement ("or" {OrElement.left=current} right=AndElement)*
;

AndElement returns Element:
	DiffEqualElement ("and" {AndElement.left=current} right=DiffEqualElement)*
;

DiffEqualElement returns Element:
	CompareElement (
		("!=" {DiffElement.left=current} right=CompareElement) |
		("==" {EqualElement.left=current} right=CompareElement)
	)*
;

CompareElement returns Element:
	PlusMinusElement(
		(">" {LargerElement.left=current} right=PlusMinusElement) |
		(">=" {LargerEqualElement.left=current} right=PlusMinusElement) |
		("<" {SmallerElement.left=current} right=PlusMinusElement) |
		("=<" {SmallerEqualElement.left=current} right=PlusMinusElement)
	)*
;

PlusMinusElement returns Element:
	MultiplicationDivisionElement(
		("+" {PlusElement.left=current} right=MultiplicationDivisionElement) |
		("-" {MinusElement.left=current} right=MultiplicationDivisionElement)
	)*
;

MultiplicationDivisionElement returns Element:
	UnaryElement (
		("*" {MultiplicationElement.left=current} right=UnaryElement) |
		("/" {DivisionElement.left=current} right=UnaryElement) |
		("%" {ModuloElement.left=current} right=UnaryElement)
	)*
;

//TO-DO  more thinking here about the UnaryElement...
UnaryElement returns Element:
	{Number_Object} value=NUMBER |
	{String_Object} value=EXTENDED_STRING |
	{Boolean_Object} value=BOOLEAN |
	"(" OrElement ")" |
	"not" {NegateElement} exp=UnaryElement
;

LBRACE: "{";
RBRACE: "}";

/**
 ServiceMetaData:
	{ServiceMetaData}
	serviceID = ID
;



EnvironmentAttribute:
	envAttributeID=ID
;

Transition:
	attributeID=ID
	from = Value
	to = Value
;

Value:
	BOOLEAN | INT | ID | EXTENDED_ID
;
*/
// ============
// Basic values
// ============

terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false';

// IMPORTANT : we are mixing terminal and non terminal rules
//  * terminal rules are parsed in a FIRST & stupid step (but fast) way by the "lexer"
//  * DataTypes rules are parsed in a SECOND step by the "parser"
//
// INFO : remember that terminal rules are executed one after the other, IN THE ORDER OF WRITING

terminal INT returns ecore::EInt: ('0'..'9')+;
NUMBER returns ecore::EBigDecimal: INT | INT '.' INT; 

terminal ID : ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|':'|'-')+;
EXTENDED_ID : ID ('.' ID)*;
EXTENDED_STRING: ID ('.' ID)* ('('')')?;
